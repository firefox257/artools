<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>canvasUX</title>
        <style>
            body { 
            margin: 0; 
            overflow: 
            hidden; display: 
            flex; justify-content: center; 
            align-items: center;
             height: 100vh; background-color: #000; }
  #canvasContainer {
    position: relative; /* Establishes a positioning context for absolute children */
    /* Ensure these dimensions match your canvas width/height for accurate overlay */
    width: 800px;
    height: 600px; /* This should match canvas height */
  }
  canvas { border: 1px solid black; }
        </style>
    </head>
    <script type="importmap">
        {
            "imports": {
                "three": "./threejs/build/three.module.js",
                "three/addons/": "./threejs/examples/jsm/",
                "globals": "./js/globals.js",
                "sharedUtils": "./sharedjs/utils.js",
                "ux": "./ui/UX.js"
            }
        }
    </script>

    <body>
        <canvas id="myCanvas" width="800" height="600"></canvas>
    </body>
    <script type="module">
        import * as THREE from 'three'
        import 'globals'
        import 'sharedUtils'
        import { mm2px, px2mm } from 'ux'
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');

		try { 
            globalThis.Msgc = function() {
                var calls = {};
                function o(id, ...args) {
                    return calls[id].func(...args);
                }
                o.func = function(id) {
                    if (calls[id] == undefined) {
                        throw new Error(`msgc id ${id} is not defined`);
                    }
                    return calls[id].func;
                };
                o.set = function(id, func) {
                    if (!calls[id] && typeof calls[id] !== 'function') {
                        calls[id] = {
                            func: func,
                            remove() {
                                o[id] = undefined;
                            }
                        }; //end calls setup single
                    } else {
                        calls[id].func = func;
                    }
                };
                o.add = function(id, func) {
                    if (!calls[id] && !Array.isArray(calls[id])) {
                        var self = (calls[id] = {
                            funcs: [func],
                            func(...args) {
                                var reta = [];
                                var funcs = self.funcs;
                                var l = funcs.length;
                                for (var i = 0; i < l; i++) {
                                    var ret = funcs[i].apply(null, args);
                                    if (ret !== undefined) reta.push(ret);
                                }
                                return reta;
                            },
                            remove(func) {
                                var a = self.funcs;
                                var l = a.length;
                                for (var i = 0; i < l; i++) {
                                    if (a[i] === func) {
                                        calls[id].splice(i, 1);
                                        break;
                                    }
                                }
                            }
                        }); //end calls setup single
                    } else {
                        calls[id].funcs.push(func);
                    }
                };
                o.remove = function(id, func) {
                    calls[id].remove(func);
                };
                o.removeAll = function(id) {
                    calls[id] = undefined;
                };

                o.runScript = function(text) {
                    var a = text
                        .split('\n')
                        .filter((n) => n.trim() !== '')
                        .map((t) => t.trim());
                    var l = a.length;
                    for (var i = 0; i < l; i++) {
                        //alert("|"+a[i]+"|");
                        eval(`o(${a[i]});`);
                        }
                };

                return o;
            };

            globalThis.$msgc = Msgc();

            // Get the canvas element
            const canvas = document.getElementById('myCanvas');

            // -- Definition of TextureCanvas class --
            class TextureCanvas { // Base Class
                static clickableInstances = [];
                static raycaster = new THREE.Raycaster();
                static mouse = new THREE.Vector2();
                constructor(initialProps = {}) {
                    this._props = {
                        // Default values for base properties owned by TextureCanvas
                        quadWidthInScene: 2,
                        meshCastShadow: true,
                        materialRoughness: 0.8,
                        materialMetalness: 0.1,
                        ...initialProps // Merge with user-provided initial props
                    }; // prettier-ignore
                    this.canvas = document.createElement('canvas');
                    // Further initialization is deferred to _completeInitialization(), called by subclass
                }

                _completeInitialization() {
                    // 1. Create 2D canvas element
                    this.updateSize(); // Subclass implements this to set canvas.width and canvas.height

                    if (this.canvas.width === 0 || this.canvas.height === 0) {
                        console.warn("Canvas dimensions are zero after updateSize(). Defaulting to 1x1.");
                        this.canvas.width = this.canvas.width || 1;
                        this.canvas.height = this.canvas.height || 1;
                    }

                    // 2. Create Three.js texture from this canvas
                    this.texture = new THREE.CanvasTexture(this.canvas);
                    this.texture.minFilter = THREE.LinearFilter; // Ensures smooth scaling down
                    this.texture.magFilter = THREE.LinearFilter; // Ensures smooth scaling up

                    // 3. Calculate aspect ratio and quad height
                    this._updateGeometryInternal(); // Creates initial geometry

                    // 5. Create material using the canvas texture
                    this.material = new THREE.MeshStandardMaterial({
                        map: this.texture,
                        side: THREE.DoubleSide,   // Render both sides of the plane
                        transparent: true,        // Enable transparency (e.g., if backgroundColor has alpha)
                        roughness: this._props.materialRoughness,
                        metalness: this._props.materialMetalness
                    });

                    // 6. Create the 3D mesh
                    this.mesh = new THREE.Mesh(this.geometry, this.material);
                    this.mesh.castShadow = this._props.meshCastShadow;

                    // 7. Perform the initial drawing onto the canvas
                    this.drawCanvasContent();
                    TextureCanvas.clickableInstances.push(this);
                }

                updateSize() {
                    throw new Error("TextureCanvas.updateSize() must be implemented by a subclass.");
                }

                drawCanvasContent() {
                    // Abstract method - subclasses must implement this to draw on the canvas.
                    // After drawing, subclasses should call this._triggerTextureUpdate().
                    throw new Error("TextureCanvas.drawCanvasContent() must be implemented by a subclass.");
                }

                onClick(details) { // details will include pixelX, pixelY, and intersection
                    throw new Error("TextureCanvas.onClick(details) must be implemented by a subclass. Details: { pixelX, pixelY, intersection }");
                }

                _updateCanvasAndTexture() {
                    if (!this.canvas || !this.texture || !this.material) return;

                    this.texture.dispose(); 
                    // Canvas dimensions are now set by updateSize() in the subclass

                    // Create new texture
                    this.texture = new THREE.CanvasTexture(this.canvas);
                    this.texture.minFilter = THREE.LinearFilter;
                    this.texture.magFilter = THREE.LinearFilter;
                    
                    this.material.map = this.texture; // Update material's map
                }

                _updateGeometryInternal() { // Renamed to avoid confusion with potential subclass methods
                    if (!this.canvas) return; // Canvas must exist for aspect ratio calculation

                    if (this.geometry) {
                        this.geometry.dispose(); // Dispose old geometry if it exists
                    }

                    // Calculate new quad height based on current props
                    const aspectRatio = this.canvas.height / Math.max(1, this.canvas.width); // Avoid division by zero
                    const quadHeightInScene = this._props.quadWidthInScene * aspectRatio;

                    // Create/update geometry
                    this.geometry = new THREE.PlaneGeometry(this._props.quadWidthInScene, quadHeightInScene);
                    if (this.mesh) { // If the mesh already exists, update its geometry
                        this.mesh.geometry = this.geometry;
                    }
                }

                _triggerTextureUpdate() {
                    if (this.texture) this.texture.needsUpdate = true;
                }

                get props() {
                    return { ...this._props }; // Return a shallow copy
                }

                set props(newPropsPartial) {
                    const oldProps = { ...this._props };
                    let changed = false;

                    // Only merge props relevant to the base class
                    for (const key in newPropsPartial) {
                        if (key in this._props) {
                            if (this._props[key] !== newPropsPartial[key]) {
                                this._props[key] = newPropsPartial[key];
                                changed = true;
                            }
                        }
                    }
                    if (this._props.quadWidthInScene !== oldProps.quadWidthInScene && this.canvas) {
                        this._updateGeometryInternal();
                        changed = true; // Ensure redraw if geometry changed
                    }

                    if (this.mesh && this._props.meshCastShadow !== oldProps.meshCastShadow) {
                        this.mesh.castShadow = this._props.meshCastShadow;
                    }
                    if (this.material && (
                        this._props.materialRoughness !== oldProps.materialRoughness ||
                        this._props.materialMetalness !== oldProps.materialMetalness
                    )) {
                        this.material.roughness = this._props.materialRoughness;
                        this.material.metalness = this._props.materialMetalness;
                        this.material.needsUpdate = true;
                        changed = true;
                    }

                    // If any relevant prop for the base class changed, allow subclass to redraw.
                    if (changed) {
                        this.drawCanvasContent();
                    }
                }

                dispose() {
                    if (this.geometry) this.geometry.dispose();
                    if (this.material) this.material.dispose();
                    if (this.texture) this.texture.dispose();
                    
                    const index = TextureCanvas.clickableInstances.indexOf(this);
                    if (index > -1) {
                        TextureCanvas.clickableInstances.splice(index, 1);
                    }

                    this.canvas = null; 
                    this.mesh = null;
                    this._props = null;
                }

                static initClickHandling(camera, rendererDomElement) {
                    if (this.clickListenerInitialized) return;

                    rendererDomElement.addEventListener('click', (event) => {
                        // Calculate mouse position in normalized device coordinates (-1 to +1) for both components
                        const rect = rendererDomElement.getBoundingClientRect();
                        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                        this.raycaster.setFromCamera(this.mouse, camera);

                        const meshesToIntersect = this.clickableInstances.map(inst => inst.mesh).filter(mesh => mesh);
                        if (meshesToIntersect.length === 0) return;

                        const intersects = this.raycaster.intersectObjects(meshesToIntersect);

                        if (intersects.length > 0) {
                            // Find which instance was clicked by comparing the intersected mesh
                            const clickedInstance = this.clickableInstances.find(inst => inst.mesh === intersects[0].object);
                            if (clickedInstance && clickedInstance.canvas && intersects[0].uv) {
                                // Convert UV coordinates to pixel coordinates on the 2D canvas
                                // UV origin is bottom-left in Three.js, Canvas origin is top-left
                                const pixelX = intersects[0].uv.x * clickedInstance.canvas.width;
                                const pixelY = (1 - intersects[0].uv.y) * clickedInstance.canvas.height;

                                clickedInstance.onClick({
                                    pixelX: pixelX,
                                    pixelY: pixelY,
                                    intersection: intersects[0]
                                });
                            } else if (clickedInstance) {
                                console.warn("Clicked instance or its canvas/uv data is missing for click processing.");
                            }
                        }
                    }, false);
                    this.clickListenerInitialized = true;
                }
            }

            class TextCanvas extends TextureCanvas {
                constructor(initialProps = {}) {
                    // Define defaults for all props (base + text-specific)
                    const allDefaults = {
                        quadWidthInScene: 2,
                        meshCastShadow: false,
                        materialRoughness: 0.8,
                        materialMetalness: 0.1,
                        // Text-specific props
                        text: "Hello World",
                        targetTextHeightIn3D: 0.5, // Desired height of the text quad in 3D scene units
                        font: 'bold 24px Arial',
                        textColor: '#FFFFFF',
                        backgroundColor: 'rgba(0, 0, 0, 0.0)', // Fully transparent background
                        padding: 10,
                        textAlign: 'center',
                        textBaseline: 'middle',
                        emissiveColor: '#000000', // Default to no emission
                        emissiveIntensity: 0.0,   // Default to no emission intensity
                    }; // prettier-ignore

                    // 1. Prepare props locally before calling super()
                    //    Start with defaults, then merge initialProps.
                    let localProps = { ...allDefaults, ...initialProps };

                    // Prepare props for the super constructor.
                    // These are props that TextureCanvas itself manages.
                    const propsToPassToSuper = {
                        quadWidthInScene: localProps.quadWidthInScene,
                        meshCastShadow: localProps.meshCastShadow,
                        materialRoughness: localProps.materialRoughness,
                        materialMetalness: localProps.materialMetalness,
                        // Pass through any other initialProps that might be relevant for TextureCanvas
                        // if TextureCanvas's _props definition were to expand.
                        // For now, explicitly list known base props.
                    }; // prettier-ignore
                    // If initialProps contains overrides for these base props, they'll be in localProps already.

                    // 2. Call super()
                    super(propsToPassToSuper);

                    // 3. Now 'this' is available. Initialize instance properties.
                    this._allProps = localProps; // Store all resolved props

                    // 4. Complete the initialization which relies on overridden methods
                    this._completeInitialization();
                    // Apply initial TextCanvas-specific material properties
                    if (this.material) {
                        this.material.emissive.set(this._allProps.emissiveColor);
                        this.material.emissiveIntensity = this._allProps.emissiveIntensity;
                    }
                    // No 3D glow mesh to create here anymore
                }

                updateSize() { // Implements base class's abstract method
                    if (!this.canvas) return; // Should not happen if called after _completeInitialization

                    const dims = TextCanvas._calculateCanvasDimensions(
                        this._allProps.text, this._allProps.font, this._allProps.padding
                    );
                    this.canvas.width = dims.width;
                    this.canvas.height = dims.height;
                }

                // Override from TextureCanvas
                _updateGeometryInternal() {
                    if (!this.canvas) return; // Canvas must exist

                    if (this.geometry) {
                        this.geometry.dispose(); // Dispose old geometry if it exists
                    }

                    // Calculate 3D quad dimensions based on targetTextHeightIn3D and canvas aspect ratio
                    const canvasAspectRatio = this.canvas.width / Math.max(1, this.canvas.height); // Width / Height
                    const quadHeight = this._allProps.targetTextHeightIn3D;
                    const quadWidth = quadHeight * canvasAspectRatio;

                    this.geometry = new THREE.PlaneGeometry(quadWidth, quadHeight);
                    if (this.mesh) { // If the mesh already exists, update its geometry
                        this.mesh.geometry = this.geometry;
                    }
                }

                static _calculateCanvasDimensions(text, font, padding) {
                    const tempCtx = document.createElement('canvas').getContext('2d');
                    tempCtx.font = font;
                    const metrics = tempCtx.measureText(text || ""); // Handle empty text
                    let textWidth = metrics.width;
                    let textHeight = (metrics.actualBoundingBoxAscent || 0) + (metrics.actualBoundingBoxDescent || 0);

                    // Fallback for height if not available (e.g., in some environments or for empty text)
                    if (textHeight === 0 && text && text.length > 0) {
                        const fontSizeMatch = font.match(/(\d+)(px|pt|em|rem)/);
                        if (fontSizeMatch && fontSizeMatch[1]) {
                            textHeight = parseInt(fontSizeMatch[1], 10) * 1.2; // Approximate height
                        } else {
                            textHeight = 24 * 1.2; // Default fallback based on common font size
                        }
                    } // prettier-ignore
                     if (textHeight === 0 && (!text || text.length === 0)) { // For truly empty text
                        textHeight = (parseInt(font.match(/(\d+)(px|pt|em|rem)/)?.[1], 10) || 24) * 0.5; // Minimal height for empty
                        textWidth = 0; // No content width
                    }

                    return {
                        width: Math.max(1, Math.ceil(textWidth + 2 * padding)),
                        height: Math.max(1, Math.ceil(textHeight + 2 * padding)),
                    };
                }

                drawCanvasContent() { // Overrides base method
                    if (!this.canvas) return;
                    const ctx = this.canvas.getContext('2d');
                    if (!ctx) return;

                    const props = this._allProps;
                    const textContentPadding = props.padding; 

                    // Always clear the canvas with the specified background color
                    ctx.fillStyle = props.backgroundColor;
                    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    // Calculate text position:
                    let x = this.canvas.width / 2; // Default for center
                    let y = this.canvas.height / 2; // Default for middle

                    // Adjust x, y based on textAlign and textBaseline, considering padding
                    if (props.textAlign === 'left') x = textContentPadding;
                    else if (props.textAlign === 'right') x = this.canvas.width - textContentPadding;

                    if (props.textBaseline === 'top') y = textContentPadding;
                    else if (props.textBaseline === 'bottom') y = this.canvas.height - textContentPadding;

                    ctx.font = props.font;
                    ctx.textAlign = props.textAlign;
                    ctx.textBaseline = props.textBaseline;

                    // --- Draw Sharp Text ---
                    ctx.fillStyle = props.textColor;
                    ctx.fillText(props.text, x, y);

                    this._triggerTextureUpdate(); // From base class
                }

                onClick(details) { // Overrides base method, receives { pixelX, pixelY, intersection }
                    if (!this.canvas || !details || details.pixelX === undefined || details.pixelY === undefined || !details.intersection) {
                        console.warn("TextCanvas onClick: Click details (pixelX, pixelY, intersection) missing or incomplete.");
                        return;
                    }
                    // Example: Change text on click. You can customize this.
                    this.props = { 
                        text: "Clicked!",
                        textColor: '#ff0000', // Change to red
                        emissiveColor: '#ff0000',
                        emissiveIntensity: 0.8
                    };

                    console.log(`TextCanvas clicked! Text: "${this._allProps.text}", 3D Point:`, details.intersection.point, `UV:`, details.intersection.uv, `2D Canvas Pixel Coords: (x: ${details.pixelX.toFixed(2)}, y: ${details.pixelY.toFixed(2)})`);
                    // You can add a custom callback prop here if needed:
                    // if (typeof this._allProps.onClickCallback === 'function') {
                    //     this._allProps.onClickCallback({
                    //         text: this._allProps.text,
                    //         ...details // Pass all details to the callback
                    //     });
                    // }
                }

                set props(newPropsPartial) {
                    const oldAllProps = { ...this._allProps };
                    this._allProps = { ...this._allProps, ...newPropsPartial }; // Update internal state first
                    let needsCanvasResizeAndTextureUpdate = false;
                    let needsGeometryUpdate = false;
                    let needsCanvasRedrawForTextCanvasProps = false; // Flag for TextCanvas-specific reasons to redraw canvas

                    // Check for changes affecting 2D canvas size
                    if (this._allProps.text !== oldAllProps.text ||
                        this._allProps.font !== oldAllProps.font ||
                        this._allProps.padding !== oldAllProps.padding) {
                        needsCanvasResizeAndTextureUpdate = true;
                        needsGeometryUpdate = true; // Canvas aspect ratio will change
                        needsCanvasRedrawForTextCanvasProps = true; // Content or its appearance changed
                    }

                    // Check for changes affecting 3D geometry target size
                    if (this._allProps.targetTextHeightIn3D !== oldAllProps.targetTextHeightIn3D) {
                        needsGeometryUpdate = true;
                        // This doesn't necessarily mean canvas content needs redraw, only 3D geometry.
                    }

                    // Check for other text-specific visual changes (e.g., color)
                    if (this._allProps.textColor !== oldAllProps.textColor ||
                        this._allProps.backgroundColor !== oldAllProps.backgroundColor) {
                        needsCanvasRedrawForTextCanvasProps = true;
                    }

                    if (needsCanvasResizeAndTextureUpdate) {
                        this.updateSize(); // Recalculate and set canvas.width/height
                        if (this.texture) this._updateCanvasAndTexture(); // Update texture from new canvas
                    }

                    if (needsGeometryUpdate) {
                        this._updateGeometryInternal(); // Call TextCanvas's overridden method
                    }

                    // Identify base props that changed or were set
                    const basePropsToUpdate = {};
                    const basePropKeys = ['quadWidthInScene', 'meshCastShadow', 'materialRoughness', 'materialMetalness'];
                    let actualBasePropsChanged = false; // True if any base prop value actually changed

                    for (const key of basePropKeys) {
                        // Check if the property is defined in _allProps and its value has actually changed.
                        if (key in this._allProps && this._allProps[key] !== oldAllProps[key]) {
                            basePropsToUpdate[key] = this._allProps[key];
                            actualBasePropsChanged = true;
                        }
                    }

                    let superDidRedraw = false;
                    if (actualBasePropsChanged) {
                        // If actual base prop values changed, TextureCanvas.props will call drawCanvasContent.
                        super.props = basePropsToUpdate; // This might trigger drawCanvasContent in base if its props changed
                        superDidRedraw = true;
                    }

                    // Update TextCanvas-specific material properties (emissive)
                    if (this.material) {
                        if (this._allProps.emissiveColor !== oldAllProps.emissiveColor) {
                            this.material.emissive.set(this._allProps.emissiveColor);
                        }
                        if (this._allProps.emissiveIntensity !== oldAllProps.emissiveIntensity) {
                            this.material.emissiveIntensity = this._allProps.emissiveIntensity;
                        }
                    }

                    // If TextCanvas-specific props require a canvas redraw, and super.props didn't already do it.
                    if (needsCanvasRedrawForTextCanvasProps && !superDidRedraw) {
                        this.drawCanvasContent();
                    }
                }
                
                dispose() {
                    super.dispose();
                }
            }
            // -- End of TextCanvas and TextureCanvas class definitions --

            // -- Definition of FloorTest class --
            class FloorTest {
                constructor(renderer, scene, arSceneOffsetGroup) {
                    this.renderer = renderer;
                    this.scene = scene;
                    this.arSceneOffsetGroup = arSceneOffsetGroup;

                    this.reticle = null;
                    this.hitTestSource = null;
                    this.hitTestSourceRequested = false;
                    this.floorOffset = 0;
                    this.floorDetected = false; // Flag to indicate if floor has been detected

                    this._initReticle();

                    // Bind event handlers to maintain 'this' context
                    this._onSessionStart = this._onSessionStart.bind(this);
                    this._onSessionEnd = this._onSessionEnd.bind(this);

                    this.renderer.xr.addEventListener('sessionstart', this._onSessionStart);
                    this.renderer.xr.addEventListener('sessionend', this._onSessionEnd);
                }

                _initReticle() {
                    this.reticle = new THREE.Mesh(
                        new THREE.RingGeometry(0.03, 0.04, 32).rotateX(-Math.PI / 2),
                        new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 })
                    );
                    this.reticle.matrixAutoUpdate = false;
                    this.reticle.visible = false;
                    this.scene.add(this.reticle);
                }

                async _onSessionStart() {
                    const session = this.renderer.xr.getSession();
                    if (session) {
                        try {
                            const viewerReferenceSpace = await session.requestReferenceSpace('viewer');
                            this.hitTestSource = await session.requestHitTestSource({ space: viewerReferenceSpace });
                            this.hitTestSourceRequested = true;
                            console.log("FloorTest: Hit test source requested.");
                        } catch (error) {
                            console.error("FloorTest: Failed to get hit test source:", error);
                            this.hitTestSourceRequested = false;
                        }
                    }
                }

                _onSessionEnd() {
                    if (this.hitTestSource) {
                        this.hitTestSource.cancel();
                        this.hitTestSource = null;
                    }
                    this.hitTestSourceRequested = false;
                    this.reticle.visible = false;
                    if (this.arSceneOffsetGroup) {
                        this.arSceneOffsetGroup.position.y = 0; // Reset offset
                    }
                    this.floorOffset = 0;
                    this.floorDetected = false; // Reset floor detection on session end
                    console.log("FloorTest: Session ended, floor detection reset.");
                }

                update(frame) {
                    if (this.floorDetected) { // If floor already detected, just ensure reticle is hidden
                        if (this.reticle.visible) this.reticle.visible = false;
                        return;
                    }

                    if (this.renderer.xr.isPresenting && frame && this.hitTestSourceRequested && this.hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const referenceSpace = this.renderer.xr.getReferenceSpace();
                            if (referenceSpace) {
                                const hitPose = hit.getPose(referenceSpace);
                                this.reticle.visible = true;
                                this.reticle.matrix.fromArray(hitPose.transform.matrix);
                                this.floorOffset = hitPose.transform.position.y;
                                if (this.arSceneOffsetGroup) {
                                    this.arSceneOffsetGroup.position.y = this.floorOffset;
                                    this.floorDetected = true; // Floor is now detected
                                    this.reticle.visible = false; // Hide reticle after detection
                                    console.log("FloorTest: Floor detected and offset applied. Reticle hidden.");
                                }
                            }
                        } else {
                            this.reticle.visible = false;
                        }
                    } else {
                        // Not presenting, no frame, or hit test source not ready/available
                        // (and floor not yet detected)
                        this.reticle.visible = false;
                    }
                }

                dispose() {
                    this.renderer.xr.removeEventListener('sessionstart', this._onSessionStart);
                    this.renderer.xr.removeEventListener('sessionend', this._onSessionEnd);
                    if (this.hitTestSource) {
                        this.hitTestSource.cancel();
                    }
                    if (this.reticle) {
                        this.scene.remove(this.reticle);
                        if (this.reticle.geometry) this.reticle.geometry.dispose();
                        if (this.reticle.material) this.reticle.material.dispose();
                        this.reticle = null;
                    }
                    console.log("FloorTest disposed.");
                }
            }
            // -- End of FloorTest class definition --

            // -- Definition of HitTest class --
            class HitTest {
                constructor(renderer) {
                    this.renderer = renderer;
                    this.hitTestSource = null;
                    this.hitTestSourceRequested = false;
                    this.hitCallback = null; // To store the callback from $msgc

                    this._onSessionStart = this._onSessionStart.bind(this);
                    this._onSessionEnd = this._onSessionEnd.bind(this);

                    this.renderer.xr.addEventListener('sessionstart', this._onSessionStart);
                    this.renderer.xr.addEventListener('sessionend', this._onSessionEnd);
                }

                async _onSessionStart() {
                    const session = this.renderer.xr.getSession();
                    if (session) {
                        try {
                            // Ensure 'viewer' reference space is requested if not already available by default for hit-testing
                            const viewerReferenceSpace = await session.requestReferenceSpace('viewer');
                            this.hitTestSource = await session.requestHitTestSource({ space: viewerReferenceSpace });
                            this.hitTestSourceRequested = true;
                            console.log("HitTest: Hit test source requested.");
                        } catch (error) {
                            console.error("HitTest: Failed to get hit test source:", error);
                            this.hitTestSourceRequested = false;
                        }
                    }
                }

                _onSessionEnd() {
                    if (this.hitTestSource) {
                        this.hitTestSource.cancel();
                        this.hitTestSource = null;
                    }
                    this.hitTestSourceRequested = false;
                    this.hitCallback = null; // Clear callback on session end
                    console.log("HitTest: Session ended, hit test source released.");
                }

                update(frame) {
                    if (!this.renderer.xr.isPresenting || !frame || !this.hitTestSourceRequested || !this.hitTestSource || !this.hitCallback) {
                        return;
                    }

                    const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const referenceSpace = this.renderer.xr.getReferenceSpace(); // Should be 'local-floor' or similar if available
                        if (referenceSpace) {
                            const hitPose = hit.getPose(referenceSpace);
                            if (hitPose) {
                                const p = hitPose.transform.position;
                                this.hitCallback(p.x, p.y, p.z); // Call the stored callback
                            }
                        }
                    }
                }

                setHitCallback(callback) {
                    this.hitCallback = (typeof callback === 'function') ? callback : null;
                }

                dispose() {
                    this.renderer.xr.removeEventListener('sessionstart', this._onSessionStart);
                    this.renderer.xr.removeEventListener('sessionend', this._onSessionEnd);
                    if (this.hitTestSource) {
                        this.hitTestSource.cancel();
                    }
                    this.hitCallback = null;
                    console.log("HitTest disposed.");
                }
            }
            // -- End of HitTest class definition --

            // -- Definition of CinematicLights class --
            class CinematicLights {
                constructor(scene) {
                    this.scene = scene;
                    this.ambientLight = null;
                    this.hemiLight = null;
                    this.directionalLight = null;

                    this._createAmbientLight();
                    this._createHemisphereLight();
                    this._createDirectionalLight();
                }

                _createAmbientLight() {
                    this.ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // Subtle white ambient light
                    this.scene.add(this.ambientLight);
                }

                _createHemisphereLight() {
                    this.hemiLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.5); // Sky color (white), ground color (light gray), intensity
                    this.hemiLight.position.set(0, 20, 0); // Position it high up
                    this.scene.add(this.hemiLight);
                }

                _createDirectionalLight() {
                    this.directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // White light, fairly strong
                    this.directionalLight.position.set(-5, 8, 6); // Position: from top-left-front
                    this.directionalLight.castShadow = true;
                    this.directionalLight.shadow.mapSize.width = 2048;
                    this.directionalLight.shadow.mapSize.height = 2048;
                    this.directionalLight.shadow.camera.near = 1;
                    this.directionalLight.shadow.camera.far = 30;
                    this.directionalLight.shadow.camera.left = -10;
                    this.directionalLight.shadow.camera.right = 10;
                    this.directionalLight.shadow.camera.top = 10;
                    this.directionalLight.shadow.camera.bottom = -10;
                    this.scene.add(this.directionalLight);
                }

                // Optional: dispose method if lights were to be removed/recreated
                dispose() {
                    if (this.ambientLight) this.scene.remove(this.ambientLight);
                    if (this.hemiLight) this.scene.remove(this.hemiLight);
                    if (this.directionalLight) this.scene.remove(this.directionalLight);
                    // Note: Three.js lights don't have explicit dispose methods for their internal resources
                    // like geometries or materials, but removing them from the scene is the primary step.
                }
            }
            // -- End of CinematicLights class definition --

            // -- Definition of Global3D class --
            class Global3D {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.renderer = null;
                    this.scene = null;
                    this.camera = null;
                    this.controls = null; // OrbitControls
                    this.arSceneOffsetGroup = null;
                    this.floorTester = null;
                    this.hitTester = null; // To hold the HitTest instance
                    this.lights = null; // To hold the CinematicLights instance
                    this.originalSceneBackground = null;

                    // XR Controllers
                    this.controller1 = null;
                    this.controller2 = null;
                    this.controllerGrip1 = null;
                    this.controllerGrip2 = null;
                    this.controllerModelFactory = new XRControllerModelFactory();


                    this._initEngine();
                    // Lighting will be initialized via $msgc
                    this._initSceneObjects(); // Must be after scene, arSceneOffsetGroup
                    this._initAR();           // Must be after renderer, scene, arSceneOffsetGroup
                    this._initControllers();  // Must be after renderer, scene
                    this._initControls();     // Must be after camera, renderer.domElement
                    this._initEventListeners();

                    // Initialize click handling for TextureCanvas instances
                    TextureCanvas.initClickHandling(this.camera, this.renderer.domElement);

                    this.renderer.setAnimationLoop(this._renderLoop.bind(this));
                }

                _initEngine() {
                    this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });
                    this.renderer.setSize(this.canvas.width, this.canvas.height);
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.xr.enabled = true;
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                    this.scene = new THREE.Scene();
                    this.originalSceneBackground = new THREE.Color(0x282c34);
                    this.scene.background = this.originalSceneBackground;

                    this.camera = new THREE.PerspectiveCamera(73, this.canvas.width / this.canvas.height, 0.01, 1000);
                    this.camera.position.set(3, 2.5, 5); // Default non-AR position
                    this.camera.updateProjectionMatrix();

                    // Group for AR content that will be offset by the floor height
                    this.arSceneOffsetGroup = new THREE.Group();
                    this.scene.add(this.arSceneOffsetGroup);
                }

                _initSceneObjects() {
                    // Plane to receive shadows (optional)
                    // const planeGeometry = new THREE.PlaneGeometry(20, 20);
                    // const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, side: THREE.DoubleSide, roughness: 0.9 });
                    // const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                    // plane.rotation.x = -Math.PI / 2;
                    // plane.receiveShadow = true;
                    // this.scene.add(plane);

                    // Scene objects (cube, myTextQuad) are now managed externally
                }

                _initAR() {
                    const arButton = ARButton.createButton(this.renderer, {
                        requiredFeatures: ['local-floor', 'hit-test']
                    });
                    document.body.appendChild(arButton);

                    this.floorTester = new FloorTest(this.renderer, this.scene, this.arSceneOffsetGroup);
                    this.hitTester = new HitTest(this.renderer); // Instantiate HitTest

                    this.renderer.xr.addEventListener('sessionstart', async () => {
                        console.log('XR session started');
                        const session = this.renderer.xr.getSession();
                        if (session) {
                            // Set scene background for AR
                            this.scene.background = null;
                            // Disable OrbitControls during AR session
                            if (this.controls) this.controls.enabled = false;

                            // Attempt to set a higher frame rate if supported
                            if (session.supportedFrameRates && session.updateTargetFrameRate) {
                                console.log("Device supported frame rates:", session.supportedFrameRates);
                                const desiredMinimumFrameRate = 70;
                                // Find the lowest supported frame rate that is > desiredMinimumFrameRate
                                const suitableRates = session.supportedFrameRates
                                    .filter(rate => rate > desiredMinimumFrameRate)
                                    .sort((a, b) => a - b); // Sort ascending to pick the lowest suitable

                                if (suitableRates.length > 0) {
                                    const targetRate = suitableRates[0]; // Pick the smallest rate > 70
                                    try {
                                        await session.updateTargetFrameRate(targetRate);
                                        console.log(`Successfully requested target frame rate: ${targetRate}Hz`);
                                    } catch (error) {
                                        console.error(`Failed to set target frame rate to ${targetRate}Hz:`, error);
                                    }
                                } else {
                                    console.log(`No supported frame rate found strictly greater than ${desiredMinimumFrameRate}Hz.`);
                                    if (session.supportedFrameRates.length > 0) {
                                        const maxSupported = Math.max(...session.supportedFrameRates);
                                        console.log(`Highest available frame rate is: ${maxSupported}Hz.`);
                                    }
                                }
                            } else {
                                console.log("XRSession does not support querying/updating frame rates on this device/browser.");
                            }
                            // FloorTest._onSessionStart is called automatically by its own event listener
                        }
                    });

                    this.renderer.xr.addEventListener('sessionend', () => {
                        console.log('XR session ended');
                        this.scene.background = this.originalSceneBackground;
                        if (this.controls) this.controls.enabled = true;
                        // FloorTest._onSessionEnd is called automatically
                        $msgc("xr session ended"); // Notify external listeners
                    });
                }

                _initControllers() {
                    this.controller1 = this.renderer.xr.getController(0);
                    this.scene.add(this.controller1);
                    this.controller1.addEventListener('selectstart', () => {
                        console.log("Controller 1 selectstart");
                        const controllerMatrix = this.controller1.matrixWorld;
                        const rayOrigin = new THREE.Vector3().setFromMatrixPosition(controllerMatrix);
                        const tempMatrix = new THREE.Matrix4().identity().extractRotation(controllerMatrix);
                        const rayDirection = new THREE.Vector3(0, 0, -1).applyMatrix4(tempMatrix).normalize();

                        TextureCanvas.raycaster.set(rayOrigin, rayDirection);
                        const meshesToIntersect = TextureCanvas.clickableInstances
                            .map(inst => inst.mesh)
                            .filter(mesh => mesh && mesh.parent === this.arSceneOffsetGroup);

                        if (meshesToIntersect.length === 0) return;
                        const intersects = TextureCanvas.raycaster.intersectObjects(meshesToIntersect, false);

                        if (intersects.length > 0) {
                            const firstIntersect = intersects[0];
                            const clickedInstance = TextureCanvas.clickableInstances.find(inst => inst.mesh === firstIntersect.object);
                            if (clickedInstance && clickedInstance.canvas && firstIntersect.uv) {
                                const pixelX = firstIntersect.uv.x * clickedInstance.canvas.width;
                                const pixelY = (1 - firstIntersect.uv.y) * clickedInstance.canvas.height;
                                console.log("AR Controller selected:", clickedInstance._allProps ? clickedInstance._allProps.text : "Unknown TextCanvas");
                                clickedInstance.onClick({ pixelX: pixelX, pixelY: pixelY, intersection: firstIntersect, source: 'xrcontroller' });
                            }
                        }
                    });
                    this.controller1.addEventListener('selectend', () => console.log("Controller 1 selectend"));

                    this.controller2 = this.renderer.xr.getController(1);
                    this.scene.add(this.controller2);
                    this.controller2.addEventListener('selectstart', () => console.log("Controller 2 selectstart"));

                    this.controllerGrip1 = this.renderer.xr.getControllerGrip(0);
                    this.controllerGrip1.add(this.controllerModelFactory.createControllerModel(this.controllerGrip1));
                    this.scene.add(this.controllerGrip1);

                    this.controllerGrip2 = this.renderer.xr.getControllerGrip(1);
                    this.controllerGrip2.add(this.controllerModelFactory.createControllerModel(this.controllerGrip2));
                    this.scene.add(this.controllerGrip2);
                }

                _initControls() { // OrbitControls
                    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.target.set(0, 0.5, 0);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.screenSpacePanning = false;
                    this.controls.minDistance = 0.5;
                    this.controls.maxDistance = 10;
                    this.controls.maxPolarAngle = Math.PI / 1.9;
                    this.controls.update();
                }

                _initEventListeners() {
                    window.addEventListener('resize', () => {
                        const width = this.canvas.clientWidth;
                        const height = this.canvas.clientHeight;
                        this.camera.aspect = width / height;
                        this.camera.updateProjectionMatrix();
                        this.renderer.setSize(width, height);
                    });
                }

                _renderLoop(timestamp, frame) {
                    if (this.renderer.xr.isPresenting && frame) {
                        if (this.floorTester) this.floorTester.update(frame);
                        if (this.hitTester) this.hitTester.update(frame); // Call hitTester update
                    } else {
                        if (this.floorTester) this.floorTester.update(null);
                        if (this.controls) this.controls.update();
                    }

                    this.renderer.render(this.scene, this.camera);

                    $msgc("animate frame update", timestamp, frame); // Allow external animation hooks
                }
            }
            // -- End of Global3D class definition --


            // Plane to receive shadows
            const planeGeometry = new THREE.PlaneGeometry(20, 20); // Large enough plane
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, side: THREE.DoubleSide, roughness: 0.9 }); // Corrected color
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            plane.receiveShadow = true; // Plane receives shadows
            //scene.add(plane); // Keep commented out if not needed for visual floor

            // Declare scene objects that will be managed externally
            let cube, myTextQuad;

            // Instantiate Global3D first, so its scene is available
            const globalApp = new Global3D(canvas);

            // Create a single instance of CinematicLights, using the scene from globalApp
            // This assumes globalApp._initEngine() has been called and this.scene is populated.
            const singleCinematicLightsInstance = new CinematicLights(globalApp.scene);
            console.log("Single CinematicLights instance created.");

            // Define how to set cinematic lights via the mediator
            $msgc.set("set cinematic lights", (lightsInstance) => {
                if (globalApp && lightsInstance) {
                    globalApp.lights = lightsInstance; 
                    console.log("Single CinematicLights instance assigned to Global3D via $msgc.");
                } else {
                    console.error("$msgc 'set cinematic lights': Invalid Global3D instance or lightsInstance provided.");
                }
            });
            // Use the mediator to set the lights for the Global3D instance
            $msgc("set cinematic lights", singleCinematicLightsInstance);

            // --- Initialize externally managed scene objects ---
            const cubeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const cubeMaterial = new THREE.MeshStandardMaterial({
                color: 0x0077ff,
                roughness: 0.5,
                metalness: 0.1
            });
            cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(0, 0.1, -0.5);
            cube.castShadow = true;
            if (globalApp.arSceneOffsetGroup) {
                globalApp.arSceneOffsetGroup.add(cube);
            }

            myTextQuad = new TextCanvas({
                text: "⛅Hello AR!",
                targetTextHeightIn3D: 0.1,
                font: 'bold 40px Arial',
                textColor: '#FFD700',
                backgroundColor: 'rgba(0, 0, 128, 0.0)',
                padding: 10,
                meshCastShadow: false,
                materialRoughness: 0.7,
                materialMetalness: 0.0,
                emissiveColor: '#FFD700',
                emissiveIntensity: 0.3,
            });
            if (myTextQuad.mesh) {
                myTextQuad.mesh.position.set(0, 0.3, -0.5); // Adjusted Y for AR
                if (globalApp.arSceneOffsetGroup) {
                    globalApp.arSceneOffsetGroup.add(myTextQuad.mesh);
                }
            }

            setTimeout(() => {
                if (myTextQuad) {
                    myTextQuad.props = {
                        text: "Floor Detected!",
                        textColor: '#00FF00',
                        emissiveColor: '#00FF00',
                        emissiveIntensity: 0.6
                    };
                }
            }, 7000);
            // --- End of externally managed scene objects initialization ---


            // Define how to register a hit test callback via the mediator
            $msgc.set("get hittest", (callback) => {
                if (globalApp && globalApp.hitTester) {
                    globalApp.hitTester.setHitCallback(callback);
                } else {
                    console.error("$msgc 'get hittest': Global3D app or HitTester not available.");
                }
            });

            // Subscribe to the animation frame update message for external animations
            $msgc.add("animate frame update", (timestamp, frame) => {
                if (cube) {
                    cube.rotation.x += 0.005;
                    cube.rotation.y += 0.005;
                }
            });

            // Subscribe to XR session end to reset positions of external objects
            $msgc.add("xr session ended", () => {
                console.log("Resetting positions of external objects after XR session ended.");
                if (cube) cube.position.set(0, 0.1, -0.5);
                if (myTextQuad && myTextQuad.mesh) myTextQuad.mesh.position.set(0, 0.3, -0.5);
            });

        } catch (err) {
            alert(err)
            alert(err.stack)
        }
    </script>
</html>
